---
phase: 03-station-chat-and-timer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/007_station_chat.sql
  - src/lib/actions/station.ts
  - src/lib/hooks/useRealtimeChat.ts
  - src/lib/hooks/useCountdownTimer.ts
  - src/lib/hooks/useAutoScroll.ts
autonomous: true
requirements: [CHAT-02, CHAT-03, CHAT-06, CHAT-07, TIMR-01, TIMR-02]

must_haves:
  truths:
    - "Opening an available station creates/activates a session with end_timestamp set 15 minutes from now"
    - "Only one station can be active per group at a time (server-side enforced)"
    - "Messages are persisted to the messages table with RLS enforcing group membership"
    - "Broadcast channel delivers messages instantly to all group members"
    - "Timer computes remaining time from server-generated end_timestamp"
    - "Chat auto-scrolls to newest message unless user has scrolled up"
  artifacts:
    - path: "supabase/migrations/007_station_chat.sql"
      provides: "RLS for realtime.messages, open_station Postgres function"
      contains: "realtime.messages"
    - path: "src/lib/actions/station.ts"
      provides: "Server actions for station operations and message persistence"
      exports: ["openStation", "sendMessage", "loadMessages"]
    - path: "src/lib/hooks/useRealtimeChat.ts"
      provides: "Supabase Broadcast subscription and message state"
      exports: ["useRealtimeChat"]
    - path: "src/lib/hooks/useCountdownTimer.ts"
      provides: "Server-timestamp countdown timer logic"
      exports: ["useCountdownTimer"]
    - path: "src/lib/hooks/useAutoScroll.ts"
      provides: "Intersection Observer auto-scroll with scroll-up detection"
      exports: ["useAutoScroll"]
  key_links:
    - from: "src/lib/actions/station.ts"
      to: "station_sessions table"
      via: "supabase upsert with UNIQUE(station_id, group_id)"
      pattern: "open_station.*upsert|ON CONFLICT"
    - from: "src/lib/hooks/useRealtimeChat.ts"
      to: "Supabase Broadcast"
      via: "channel.on('broadcast') subscription"
      pattern: "supabase\\.channel.*private.*broadcast"
    - from: "src/lib/hooks/useCountdownTimer.ts"
      to: "end_timestamp prop"
      via: "setInterval computing remaining from end_timestamp - Date.now()"
      pattern: "setInterval.*end_timestamp|endTimestamp"

user_setup:
  - service: supabase-realtime
    why: "Private Broadcast channels require disabling public Realtime access"
    dashboard_config:
      - task: "Disable 'Enable Realtime for anonymous users' toggle"
        location: "Supabase Dashboard -> Project Settings -> API -> Realtime Settings -> Uncheck 'Enable Realtime for anonymous users'"
---

<objective>
Build the station backend infrastructure: database migration for Realtime channel authorization and atomic station opening, server actions for station operations and message persistence, and React hooks for real-time chat, countdown timer, and auto-scroll.

Purpose: This plan creates all the non-UI building blocks that Phase 3 UI components will consume. Separating backend/hooks from UI keeps each plan within context budget and allows the executor to focus on correctness of real-time logic without UI concerns.

Output: 1 SQL migration, 1 server action file (3 exports), 3 React hooks ready for import by Plan 02 UI components.
</objective>

<execution_context>
@/Users/mariusvalle-olsen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mariusvalle-olsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-station-chat-and-timer/03-RESEARCH.md
@supabase/migrations/001_schema.sql
@supabase/migrations/002_rls.sql
@src/lib/supabase/client.ts
@src/lib/supabase/server.ts
@src/lib/actions/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and server actions for station operations</name>
  <files>
    supabase/migrations/007_station_chat.sql
    src/lib/actions/station.ts
  </files>
  <action>
**Migration file `007_station_chat.sql`:**

Create a SQL migration that:

1. **RLS policy on `realtime.messages`** for private Broadcast channel authorization. This policy allows authenticated users to send/receive on channels named `station:{sessionId}` if they are a member of the group associated with that session. Use the pattern from research:
   ```sql
   CREATE POLICY "Group members can use station channels"
   ON "realtime"."messages"
   FOR ALL
   TO authenticated
   USING (
     EXISTS (
       SELECT 1
       FROM station_sessions ss
       JOIN group_members gm ON gm.group_id = ss.group_id
       WHERE gm.user_id = (SELECT auth.uid())
         AND 'station:' || ss.id::text = (SELECT realtime.topic())
         AND realtime.messages.extension IN ('broadcast', 'presence')
     )
   )
   WITH CHECK (
     EXISTS (
       SELECT 1
       FROM station_sessions ss
       JOIN group_members gm ON gm.group_id = ss.group_id
       WHERE gm.user_id = (SELECT auth.uid())
         AND 'station:' || ss.id::text = (SELECT realtime.topic())
         AND realtime.messages.extension IN ('broadcast', 'presence')
     )
   );
   ```

2. **`open_station` Postgres function** that atomically opens a station for a group. Uses `INSERT ... ON CONFLICT` on the `UNIQUE(station_id, group_id)` constraint:
   - If no row exists: INSERT with status='active', started_at=now(), end_timestamp=now()+interval '15 minutes'
   - If row exists with status='available': UPDATE to status='active', set started_at/end_timestamp only if they are NULL (COALESCE preserves first opener's timestamp)
   - If row exists with status='active': return existing row (no update needed)
   - If row exists with status='completed': return error/null
   - Before inserting/updating, check that no OTHER station is active for this group (one-active constraint)
   - Returns the session row (id, end_timestamp, status)
   - Function should be `SECURITY DEFINER` so it can bypass RLS for the atomicity check

**Server actions file `src/lib/actions/station.ts`:**

Create 3 server actions following the established pattern from `src/lib/actions/admin.ts` (use `createClient` from `@/lib/supabase/server`, get user via `getUser()`):

1. **`openStation(stationId: string)`** — Opens a station for the current user's group:
   - Get the current user and their group_id (via group_members table)
   - Call the `open_station` Postgres function via `.rpc('open_station', { p_station_id: stationId, p_group_id: groupId })`
   - Return `{ sessionId: string, endTimestamp: string }` on success or `{ error: string }` on failure
   - Error messages in Norwegian: 'Ikke autentisert', 'Du er ikke i en gruppe', 'Gruppen har allerede en aktiv stasjon', 'Stasjonen er allerede fullfort'

2. **`sendMessage(data: { id: string, sessionId: string, content: string })`** — Persists a chat message:
   - Get current user
   - Insert into `messages` table with `id`, `session_id`, `user_id`, `content`
   - RLS enforces group membership (no manual check needed)
   - Return `{}` on success or `{ error: string }` on failure
   - Trim content, reject empty messages

3. **`loadMessages(sessionId: string)`** — Loads message history for a session:
   - Get current user (for auth)
   - Select messages joined with profiles (for full_name, role) for the given session_id
   - Order by created_at ASC
   - Return `{ messages: Array<{ id, userId, fullName, role, content, createdAt }> }` or `{ error: string }`
   - RLS on messages table enforces group membership
  </action>
  <verify>
1. Run `npm run build` -- should compile with zero errors
2. Verify the migration file exists and contains the RLS policy for realtime.messages and the open_station function
3. Verify station.ts exports openStation, sendMessage, loadMessages
  </verify>
  <done>
Migration file creates Realtime RLS policy and open_station function. Three server actions compile: openStation calls the RPC, sendMessage inserts to messages table, loadMessages fetches history with profile joins.
  </done>
</task>

<task type="auto">
  <name>Task 2: React hooks for real-time chat, countdown timer, and auto-scroll</name>
  <files>
    src/lib/hooks/useRealtimeChat.ts
    src/lib/hooks/useCountdownTimer.ts
    src/lib/hooks/useAutoScroll.ts
  </files>
  <action>
Create the `src/lib/hooks/` directory (it does not exist yet).

**`useRealtimeChat.ts`** — Supabase Broadcast subscription hook:

Follow the research pattern exactly. The hook:
- Accepts `sessionId: string` and `currentUserId: string`
- Creates a Supabase client via `createClient` from `@/lib/supabase/client`
- Calls `supabase.realtime.setAuth()` before subscribing (CRITICAL for private channels)
- Subscribes to channel `station:${sessionId}` with `{ config: { private: true, broadcast: { self: true, ack: false } } }`
- Listens for `'new-message'` broadcast events
- Maintains `messages` state as `ChatMessage[]` where:
  ```typescript
  type ChatMessage = {
    id: string
    userId: string
    fullName: string
    role: 'youth' | 'parent'
    content: string
    createdAt: string
  }
  ```
- Deduplicates by message ID on receive (incoming message replaces optimistic one)
- Uses `cancelled` flag pattern to prevent subscription after unmount
- Returns cleanup in useEffect that calls `channel.unsubscribe()`
- Exports `{ messages, setMessages, sendBroadcast }` where `sendBroadcast` sends via `channel.send({ type: 'broadcast', event: 'new-message', payload: message })`
- `setMessages` is exposed so the page can merge initial history from loadMessages

**`useCountdownTimer.ts`** — Server-timestamp countdown timer:

Follow the research pattern exactly:
- Accepts `endTimestamp: string | null`
- Computes `remaining` in seconds: `Math.max(0, Math.floor((new Date(endTimestamp).getTime() - Date.now()) / 1000))`
- Uses `setInterval(1000)` to update every second
- Returns `{ remaining, color, expired, display }` where:
  - `color`: `'white'` if remaining > 300, `'yellow'` if 60 < remaining <= 300, `'red'` if remaining <= 60
  - `expired`: `remaining <= 0`
  - `display`: `'Tiden er ute!'` if expired, else `MM:SS` formatted (padded with leading zeros)
- Cleans up interval on unmount

**`useAutoScroll.ts`** — Intersection Observer auto-scroll:

Follow the research pattern exactly:
- Uses `useRef` for containerRef, sentinelRef, and isAtBottomRef
- Sets up IntersectionObserver on the sentinel element with threshold 0.1
- `isAtBottomRef.current` tracks whether user is at the bottom
- When dependency array changes (new message), scrolls sentinel into view ONLY if `isAtBottomRef.current === true`
- Exports `{ containerRef, sentinelRef, scrollToBottom }` where `scrollToBottom` forces scroll to bottom
- The dependency array is passed as a parameter: `useAutoScroll(deps: unknown[])`

All hooks must have `"use client"` directive at the top. Export each hook as a named export. Use the types established in the codebase (no `any`).
  </action>
  <verify>
1. Run `npm run build` -- should compile with zero errors
2. Verify all 3 hook files exist in src/lib/hooks/
3. Verify each hook has "use client" directive and named export
  </verify>
  <done>
Three hooks compile and export correctly: useRealtimeChat manages Broadcast subscription with deduplication, useCountdownTimer computes remaining time with color states, useAutoScroll tracks scroll position via IntersectionObserver.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. Migration file `007_station_chat.sql` contains RLS policy for `realtime.messages` and `open_station` function
3. `src/lib/actions/station.ts` exports `openStation`, `sendMessage`, `loadMessages`
4. `src/lib/hooks/useRealtimeChat.ts` exports `useRealtimeChat` with Broadcast subscription
5. `src/lib/hooks/useCountdownTimer.ts` exports `useCountdownTimer` with color/expired/display
6. `src/lib/hooks/useAutoScroll.ts` exports `useAutoScroll` with containerRef/sentinelRef
7. No TypeScript `any` types used
</verification>

<success_criteria>
- All 5 files created and project builds successfully
- Server actions follow established pattern (getUser, return { error } on failure)
- Hooks follow React 19 patterns (useEffect cleanup, no deprecated APIs)
- open_station function handles race conditions atomically
- Realtime RLS policy correctly joins station_sessions -> group_members
</success_criteria>

<output>
After completion, create `.planning/phases/03-station-chat-and-timer/03-01-SUMMARY.md`
</output>
