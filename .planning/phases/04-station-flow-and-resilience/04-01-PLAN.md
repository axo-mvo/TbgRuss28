---
phase: 04-station-flow-and-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/008_complete_station.sql
  - src/lib/actions/station.ts
  - src/lib/hooks/useRealtimeChat.ts
  - src/components/station/ChatRoom.tsx
  - src/components/station/StationHeader.tsx
autonomous: true
requirements: [FLOW-01, FLOW-02]

must_haves:
  truths:
    - "Any group member can tap 'Avslutt' and confirm to end the current station"
    - "After ending, all group members (including the ender) are redirected to /dashboard"
    - "The complete_station Postgres function atomically transitions status from active to completed"
    - "If two members click end simultaneously, both succeed without errors (idempotent)"
  artifacts:
    - path: "supabase/migrations/008_complete_station.sql"
      provides: "complete_station Postgres function"
      contains: "SECURITY DEFINER"
    - path: "src/lib/actions/station.ts"
      provides: "endStation server action"
      exports: ["endStation"]
    - path: "src/lib/hooks/useRealtimeChat.ts"
      provides: "station-ended broadcast listener and readOnly parameter"
      exports: ["useRealtimeChat"]
    - path: "src/components/station/ChatRoom.tsx"
      provides: "End station dialog and readOnly rendering mode"
    - path: "src/components/station/StationHeader.tsx"
      provides: "Avslutt button in header"
  key_links:
    - from: "src/components/station/ChatRoom.tsx"
      to: "src/lib/actions/station.ts"
      via: "endStation server action call"
      pattern: "endStation\\(sessionId\\)"
    - from: "src/components/station/ChatRoom.tsx"
      to: "src/lib/hooks/useRealtimeChat.ts"
      via: "channelRef broadcast of station-ended event"
      pattern: "station-ended"
    - from: "src/lib/hooks/useRealtimeChat.ts"
      to: "router.push('/dashboard')"
      via: "onStationEnded callback on broadcast receive"
      pattern: "onStationEnded"
    - from: "src/lib/actions/station.ts"
      to: "supabase/migrations/008_complete_station.sql"
      via: "supabase.rpc('complete_station')"
      pattern: "rpc.*complete_station"
---

<objective>
Add "end station" flow: a confirmation dialog that calls a complete_station Postgres function, broadcasts a station-ended event to all group members via the existing Broadcast channel, and redirects everyone back to /dashboard. Also add readOnly mode to ChatRoom and useRealtimeChat so completed stations render without input or subscription.

Purpose: Groups need to finish a station discussion and move to the next one. The end-station action must be atomic (race-safe), broadcast to all members, and leave the ChatRoom ready for read-only viewing.
Output: complete_station Postgres function, endStation server action, modified useRealtimeChat with station-ended listener + readOnly param, modified ChatRoom with end dialog + readOnly banner, modified StationHeader with "Avslutt" button.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-station-flow-and-resilience/04-RESEARCH.md
@.planning/phases/03-station-chat-and-timer/03-01-SUMMARY.md
@.planning/phases/03-station-chat-and-timer/03-02-SUMMARY.md
@supabase/migrations/007_station_chat.sql
@src/lib/actions/station.ts
@src/lib/hooks/useRealtimeChat.ts
@src/components/station/ChatRoom.tsx
@src/components/station/StationHeader.tsx
@src/components/ui/Dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: complete_station Postgres function and endStation server action</name>
  <files>supabase/migrations/008_complete_station.sql, src/lib/actions/station.ts</files>
  <action>
1. Create `supabase/migrations/008_complete_station.sql`:
   - Mirror the `open_station` pattern from `007_station_chat.sql` (SECURITY DEFINER, FOR UPDATE row lock, JSON return).
   - Function signature: `complete_station(p_session_id UUID) RETURNS JSON`.
   - Lock the station_sessions row with `FOR UPDATE`.
   - If session not found, return `json_build_object('error', 'Okt ikke funnet')`.
   - If session status is NOT 'active', return `json_build_object('success', true)` -- treat already-completed as success (idempotent), not an error. This prevents the second user who clicks "end" from seeing an error toast.
   - If status IS 'active', UPDATE to `status = 'completed'`, `completed_at = now()`, then return `json_build_object('success', true)`.

2. Add `endStation` server action to `src/lib/actions/station.ts`:
   - Follow the exact pattern of `openStation`: createClient, getUser, verify membership via station_sessions join to group_members.
   - Signature: `endStation(sessionId: string): Promise<{ error?: string }>`.
   - Fetch the session's group_id from station_sessions by session ID.
   - Verify user is in the group via group_members lookup (same pattern as sendMessage membership check).
   - Call `supabase.rpc('complete_station', { p_session_id: sessionId })`.
   - If RPC error, return `{ error: 'Kunne ikke avslutte stasjonen' }`.
   - Parse result JSON. If result.error, return it. Otherwise return `{}` (success).
   - Add `'use server'` is already at top of file -- just add the new export.
  </action>
  <verify>Run `npx next build` -- no TypeScript errors. Verify 008_complete_station.sql file exists and contains SECURITY DEFINER. Verify station.ts exports endStation.</verify>
  <done>complete_station Postgres function created with idempotent completion logic. endStation server action added following established pattern, callable from client components.</done>
</task>

<task type="auto">
  <name>Task 2: useRealtimeChat readOnly mode, station-ended listener, and ChatRoom end-station UI</name>
  <files>src/lib/hooks/useRealtimeChat.ts, src/components/station/ChatRoom.tsx, src/components/station/StationHeader.tsx</files>
  <action>
1. Modify `src/lib/hooks/useRealtimeChat.ts`:
   - Add `readOnly` boolean and `onStationEnded` callback to the hook parameters. New signature: `useRealtimeChat(sessionId: string, currentUserId: string, options?: { readOnly?: boolean; onStationEnded?: () => void })`.
   - CRITICAL: The hook MUST always be called (no conditional hook calls). When `readOnly` is true, skip the `setAuth()` and channel subscription inside the useEffect -- just return early from the effect body. The hook still returns `{ messages, setMessages, sendBroadcast, addOptimistic, channelRef }` with the same shape.
   - When NOT readOnly, add a second `.on('broadcast', { event: 'station-ended' }, ...)` listener on the channel (chained before `.subscribe()`). On receiving this event, call `onStationEnded?.()`.
   - Expose `channelRef` in the return value so ChatRoom can broadcast the station-ended event directly.

2. Modify `src/components/station/ChatRoom.tsx`:
   - Add `readOnly` prop (default: false) to ChatRoomProps.
   - Import `useRouter` from 'next/navigation'.
   - Import `endStation` from '@/lib/actions/station'.
   - Import `Dialog` from '@/components/ui/Dialog'.
   - Import `useState` from 'react'.
   - Pass `readOnly` and an `onStationEnded` callback to `useRealtimeChat`. The callback should call `router.push('/dashboard')`.
   - Destructure `channelRef` from useRealtimeChat return.
   - Add state: `showEndDialog` (boolean), `ending` (boolean).
   - Create `handleEndStation` async function:
     a. Set `ending = true`.
     b. Call `const result = await endStation(sessionId)`.
     c. If `result.error`, set `ending = false` and return (could add console.error).
     d. Broadcast `station-ended` event on channelRef: `await channelRef.current?.send({ type: 'broadcast', event: 'station-ended', payload: { sessionId } })`.
     e. Call `router.push('/dashboard')`.
   - Pass `onEndStation={() => setShowEndDialog(true)}` and `readOnly` to StationHeader.
   - Conditionally render ChatInput only when NOT readOnly.
   - When readOnly, show a banner at the bottom: `<div className="px-4 py-3 bg-text-muted/10 text-center text-sm text-text-muted border-t border-text-muted/10">Diskusjonen er avsluttet</div>`.
   - Render the Dialog component at the bottom of the return JSX:
     ```
     <Dialog
       open={showEndDialog}
       onClose={() => setShowEndDialog(false)}
       onConfirm={handleEndStation}
       title="Avslutt stasjon?"
       description="Er du sikker pa at du vil avslutte? Alle gruppemedlemmer sendes tilbake til stasjonsoversikten."
       confirmLabel="Avslutt"
       confirmVariant="danger"
       loading={ending}
     />
     ```

3. Modify `src/components/station/StationHeader.tsx`:
   - Add `onEndStation?: () => void` and `readOnly?: boolean` to StationHeaderProps.
   - When NOT readOnly and onEndStation is provided, render an "Avslutt" button to the LEFT of the countdown timer area. Use a compact text button: `<button type="button" onClick={onEndStation} className="text-xs px-2 py-1 rounded-md bg-white/15 hover:bg-white/25 transition-colors">Avslutt</button>`.
   - When readOnly is true, do NOT render the back-button's onClick as router.push (keep it the same -- back to dashboard is fine). Do NOT render CountdownTimer (pass endTimestamp={null} or conditionally hide it). Instead, show a small "Fullfort" label where the timer was.
  </action>
  <verify>Run `npx next build` -- zero errors, zero warnings. Verify useRealtimeChat accepts readOnly and onStationEnded parameters. Verify ChatRoom renders Dialog when showEndDialog is true. Verify StationHeader shows "Avslutt" button when onEndStation is provided.</verify>
  <done>End station flow complete: user taps "Avslutt" in header, confirms in dialog, server action marks station completed, broadcast redirects all group members to /dashboard. ChatRoom supports readOnly mode with hidden input and "Diskusjonen er avsluttet" banner. useRealtimeChat skips subscription in readOnly mode.</done>
</task>

</tasks>

<verification>
- `npx next build` passes with zero errors and zero warnings
- `supabase/migrations/008_complete_station.sql` exists with SECURITY DEFINER function
- `src/lib/actions/station.ts` exports `endStation`
- `useRealtimeChat` accepts `readOnly` and `onStationEnded` options
- ChatRoom renders "Avslutt" button in header when not readOnly
- ChatRoom renders confirmation dialog with "Avslutt stasjon?" title
- ChatRoom hides ChatInput and shows "Diskusjonen er avsluttet" banner when readOnly
- StationHeader shows "Fullfort" label instead of timer when readOnly
</verification>

<success_criteria>
1. The end station flow compiles: endStation action -> complete_station RPC -> broadcast station-ended -> router.push('/dashboard')
2. ChatRoom in readOnly mode shows messages without input or realtime subscription
3. Build passes with zero errors and zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-station-flow-and-resilience/04-01-SUMMARY.md`
</output>
