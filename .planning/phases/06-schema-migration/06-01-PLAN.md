---
phase: 06-schema-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [supabase/migrations/020_meetings_migration.sql]
autonomous: true
requirements: [MEET-03, MEET-05, SCOPE-03]

must_haves:
  truths:
    - "A meetings table migration file exists with CREATE TABLE, partial unique index, FK additions, backfill, constraint enforcement, RLS policies, and DROP of meeting_status"
    - "The migration is wrapped in BEGIN/COMMIT for atomicity"
    - "The partial unique index on meetings enforces only one upcoming meeting at a time"
    - "All existing v1.0 stations and groups get a meeting_id FK pointing to a backfilled 'Fellesmote #1' meeting with status 'completed'"
    - "The stations.number UNIQUE constraint is replaced with a per-meeting compound UNIQUE on (meeting_id, number)"
  artifacts:
    - path: "supabase/migrations/020_meetings_migration.sql"
      provides: "Complete multi-meeting schema migration"
      contains: "CREATE TABLE meetings"
  key_links:
    - from: "meetings.id"
      to: "stations.meeting_id, groups.meeting_id"
      via: "FK with ON DELETE CASCADE"
      pattern: "REFERENCES meetings\\(id\\) ON DELETE CASCADE"
    - from: "stations.meeting_id + stations.number"
      to: "idx_stations_meeting_number"
      via: "compound unique index replacing global stations_number_key"
      pattern: "CREATE UNIQUE INDEX idx_stations_meeting_number"
---

<objective>
Write the complete Postgres migration SQL file that transforms the single-meeting v1.0 schema into a multi-meeting v1.1 schema.

Purpose: This migration is the foundation for all v1.1 features. Without it, stations, groups, sessions, and messages cannot be scoped to individual meetings.

Output: A single SQL migration file at `supabase/migrations/020_meetings_migration.sql` ready to be applied to the Supabase database via the Dashboard SQL Editor.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-schema-migration/06-RESEARCH.md

<interfaces>
<!-- The migration operates on existing tables. Key schema from 001_schema.sql: -->

From supabase/migrations/001_schema.sql:
```sql
CREATE TABLE groups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  locked BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE stations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  number INT UNIQUE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  questions JSONB DEFAULT '[]',
  tip TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE station_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  station_id UUID NOT NULL REFERENCES stations(id) ON DELETE CASCADE,
  group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'available' CHECK (status IN ('available', 'active', 'completed')),
  started_at TIMESTAMPTZ,
  end_timestamp TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(station_id, group_id)
);

CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES station_sessions(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE meeting_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'active', 'completed')),
  started_at TIMESTAMPTZ,
  ended_at TIMESTAMPTZ
);
```

<!-- Constraint to drop (from 001_schema.sql): -->
stations.number has UNIQUE constraint named `stations_number_key`

<!-- station_sessions already has REPLICA IDENTITY FULL (from 010_realtime_replica_identity.sql) -->
<!-- station_sessions is already in supabase_realtime publication (from 009_view_station_and_realtime.sql) -->

<!-- Existing RPC functions (all operate on UUIDs, no changes needed per research audit):
  - open_station(p_station_id, p_group_id)
  - view_station(p_station_id, p_group_id)
  - complete_station(p_session_id)
  - reopen_station(p_session_id, p_extra_minutes)
  - check_parent_child_separation(p_group_id, p_user_id)
  - is_admin()
  - validate_invite_code(p_code)
-->

<!-- meeting_status has ZERO references in src/ (verified by grep) -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write the multi-meeting schema migration SQL</name>
  <files>supabase/migrations/020_meetings_migration.sql</files>
  <action>
Create `supabase/migrations/020_meetings_migration.sql` with the following structure, wrapped in a single transaction (BEGIN/COMMIT):

**STEP 1 — Create meetings table:**
```sql
CREATE TABLE meetings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'upcoming'
    CHECK (status IN ('upcoming', 'active', 'completed')),
  date DATE,
  time TIME,
  venue TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
ALTER TABLE meetings ENABLE ROW LEVEL SECURITY;
```

**STEP 2 — Partial unique index for "only one upcoming meeting" (MEET-03):**
```sql
CREATE UNIQUE INDEX idx_one_upcoming_meeting
  ON meetings ((true))
  WHERE status = 'upcoming';
```
This ensures only one row can have `status = 'upcoming'` at any time. A second INSERT with `status = 'upcoming'` raises a unique violation.

**STEP 3 — Add meeting_id FK columns (nullable first):**
```sql
ALTER TABLE stations ADD COLUMN meeting_id UUID REFERENCES meetings(id) ON DELETE CASCADE;
ALTER TABLE groups ADD COLUMN meeting_id UUID REFERENCES meetings(id) ON DELETE CASCADE;
```

**STEP 4 — Backfill: create "Fellesmote #1" as completed meeting and link all existing data (MEET-05):**
```sql
DO $$
DECLARE
  v_meeting_id UUID;
BEGIN
  INSERT INTO meetings (title, status, date)
  VALUES ('Fellesmøte #1', 'completed', '2026-02-19')
  RETURNING id INTO v_meeting_id;

  UPDATE stations SET meeting_id = v_meeting_id;
  UPDATE groups SET meeting_id = v_meeting_id;
END $$;
```
Use the Norwegian character ø in "Fellesmøte". The date 2026-02-19 is when v1.0 shipped.

**STEP 5 — Enforce NOT NULL after backfill:**
```sql
ALTER TABLE stations ALTER COLUMN meeting_id SET NOT NULL;
ALTER TABLE groups ALTER COLUMN meeting_id SET NOT NULL;
```

**STEP 6 — Update unique constraints (stations.number per-meeting):**
```sql
ALTER TABLE stations DROP CONSTRAINT stations_number_key;
CREATE UNIQUE INDEX idx_stations_meeting_number ON stations(meeting_id, number);
```
This allows each meeting to have its own station numbering (e.g., station 1 in meeting A and station 1 in meeting B).

**STEP 7 — RLS policies for meetings table:**
```sql
-- All authenticated users can view meetings (needed for dashboard, station selector)
CREATE POLICY "Authenticated users can view all meetings"
  ON meetings FOR SELECT
  TO authenticated
  USING (true);

-- Only admins can create, update, delete meetings
CREATE POLICY "Admins can manage meetings"
  ON meetings FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());
```

**STEP 8 — Drop obsolete meeting_status table:**
```sql
DROP TABLE IF EXISTS meeting_status;
```
This table has zero references in app code (verified by grep on `src/`). It is replaced by the `meetings.status` column.

**STEP 9 — Performance indexes:**
```sql
CREATE INDEX idx_stations_meeting_id ON stations(meeting_id);
CREATE INDEX idx_groups_meeting_id ON groups(meeting_id);
```

**Important notes:**
- Do NOT rename any existing tables. The migration adds `meeting_id` columns to existing `stations` and `groups` tables.
- Do NOT create new replacement tables. Existing UUIDs must be preserved.
- Do NOT modify any existing Postgres RPC functions — they all operate on UUIDs that are already meeting-scoped via FK chains.
- Do NOT modify any existing RLS policies — they scope via group_id which is now meeting-scoped.
- Do NOT add the meetings table to the Realtime publication — that is Phase 7's concern.
- The file header comment should explain the migration purpose and list the 9 steps.
  </action>
  <verify>
    <automated>grep -c "BEGIN" supabase/migrations/020_meetings_migration.sql && grep -c "COMMIT" supabase/migrations/020_meetings_migration.sql && grep -c "CREATE TABLE meetings" supabase/migrations/020_meetings_migration.sql && grep -c "idx_one_upcoming_meeting" supabase/migrations/020_meetings_migration.sql && grep -c "Fellesmøte" supabase/migrations/020_meetings_migration.sql && grep -c "DROP TABLE" supabase/migrations/020_meetings_migration.sql && grep -c "idx_stations_meeting_number" supabase/migrations/020_meetings_migration.sql</automated>
  </verify>
  <done>
    - `supabase/migrations/020_meetings_migration.sql` exists
    - File contains BEGIN/COMMIT transaction wrapper
    - meetings table created with status CHECK constraint and partial unique index
    - stations and groups have meeting_id FK columns added, backfilled, and enforced NOT NULL
    - Backfill inserts "Fellesmøte #1" with status 'completed' and date '2026-02-19'
    - stations_number_key dropped and replaced with compound (meeting_id, number) unique index
    - RLS policies created: all authenticated can SELECT, admins can manage
    - meeting_status table dropped
    - Performance indexes on stations.meeting_id and groups.meeting_id
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ALL_MIGRATIONS.sql reference file</name>
  <files>supabase/migrations/ALL_MIGRATIONS.sql</files>
  <action>
Append the contents of `020_meetings_migration.sql` to `supabase/migrations/ALL_MIGRATIONS.sql` with a separator comment header, following the existing pattern in that file.

Read `ALL_MIGRATIONS.sql` first to understand the existing format (each migration is appended with a comment header like `-- ========== 019_update_stations_5.sql ==========`), then append the new migration in the same style.

This keeps ALL_MIGRATIONS.sql as a complete reference of all applied migrations.
  </action>
  <verify>
    <automated>grep -c "020_meetings_migration" supabase/migrations/ALL_MIGRATIONS.sql</automated>
  </verify>
  <done>
    - ALL_MIGRATIONS.sql contains the 020_meetings_migration.sql content
    - Comment header follows existing pattern
  </done>
</task>

</tasks>

<verification>
1. `supabase/migrations/020_meetings_migration.sql` exists and contains valid SQL
2. The migration is wrapped in BEGIN/COMMIT
3. All 9 steps are present in order: CREATE TABLE, partial index, ADD COLUMN (x2), DO $$ backfill, SET NOT NULL (x2), DROP/CREATE constraints, RLS policies (x2), DROP TABLE, CREATE INDEX (x2)
4. The backfill creates a meeting titled "Fellesmøte #1" with status 'completed' and date '2026-02-19'
5. No existing tables are renamed or recreated
6. No existing RPC functions are modified
7. No existing RLS policies are modified
8. ALL_MIGRATIONS.sql is updated with the new migration
</verification>

<success_criteria>
- The migration SQL file is syntactically valid and complete
- Transaction boundaries (BEGIN/COMMIT) ensure atomicity
- The partial unique index pattern correctly enforces the "one upcoming meeting" constraint
- UUID preservation is guaranteed (backfill uses UPDATE, not INSERT/SELECT into new tables)
- The file is ready to copy-paste into the Supabase Dashboard SQL Editor
</success_criteria>

<output>
After completion, create `.planning/phases/06-schema-migration/06-01-SUMMARY.md`
</output>
