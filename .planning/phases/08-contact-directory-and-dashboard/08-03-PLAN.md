# Plan 08-03: Meeting-State-Aware Dashboard Restructuring

---
wave: 2
depends_on:
  - 08-01
  - 08-02
files_modified:
  - src/app/dashboard/page.tsx
  - src/components/dashboard/UpcomingMeetingCard.tsx
  - src/components/dashboard/PreviousMeetingsList.tsx
requirements:
  - DASH-01
  - DASH-02
  - DIR-01
  - DIR-02
  - DIR-03
  - DIR-04
  - SCOPE-02
autonomous: true
---

## Goal

Restructure the participant dashboard to be meeting-state-aware: show different content based on whether there is an upcoming meeting, an active meeting, or no current meeting. Wire in the new ContactDirectory (from 08-02), per-meeting AttendingToggle (from 08-01), an UpcomingMeetingCard, and a PreviousMeetingsList. The dashboard becomes the permanent hub with the contact directory always visible.

## must_haves

- [ ] Dashboard server component detects meeting state (upcoming / active / none) via parallel Supabase queries
- [ ] When an active meeting exists AND user has a locked group for that meeting: show station selector (existing behavior, but scoped to the active meeting's stations)
- [ ] When an upcoming meeting exists: show `UpcomingMeetingCard` with meeting info, attendance count, and per-meeting `AttendingToggle`
- [ ] Contact directory (`ContactDirectory`) is ALWAYS shown on the dashboard regardless of meeting state
- [ ] `PreviousMeetingsList` shows completed meetings with date, venue, and attendance count below the directory
- [ ] Data fetching uses `Promise.all()` for independent queries to eliminate waterfall
- [ ] Group membership query is scoped to the active meeting's ID (not global)

## Context for Executor

### Existing dashboard to restructure
The current `src/app/dashboard/page.tsx` has this structure:
1. Auth check + profile fetch
2. Group membership query (NOT meeting-scoped -- must fix)
3. Station + session fetch (NOT meeting-scoped -- must fix)
4. Youth/parent data fetch for RegisteredUsersOverview
5. Conditional render: locked group with stations OR unlocked view with RegisteredUsersOverview

### New dashboard layout (top to bottom)
```
┌─────────────────────────────────────┐
│ Welcome header + role badge         │
│ (existing)                          │
├─────────────────────────────────────┤
│ Admin panel link (if admin)         │
│ (existing, unchanged)              │
├─────────────────────────────────────┤
│ ┌─ IF ACTIVE MEETING + LOCKED GROUP ┐│
│ │ Group assignment card             ││
│ │ StationSelector                   ││
│ └───────────────────────────────────┘│
│ ┌─ IF UPCOMING MEETING ─────────────┐│
│ │ UpcomingMeetingCard               ││
│ │ (title, date/time, venue,         ││
│ │  attendance count, toggle)        ││
│ └───────────────────────────────────┘│
│ ┌─ IF NO GROUP BUT ASSIGNED ────────┐│
│ │ Group preview (existing unlocked) ││
│ └───────────────────────────────────┘│
│ ┌─ PARENT INVITE BANNER ────────────┐│
│ │ (existing, if applicable)         ││
│ └───────────────────────────────────┘│
├─────────────────────────────────────┤
│ ContactDirectory (ALWAYS shown)     │
│ Search + tab toggle + list          │
├─────────────────────────────────────┤
│ PreviousMeetingsList                │
│ (completed meetings, if any)        │
├─────────────────────────────────────┤
│ Logout button                       │
└─────────────────────────────────────┘
```

### Meeting-state detection
```typescript
// Parallel fetch in dashboard page.tsx
const [upcomingResult, activeResult, previousResult] = await Promise.all([
  supabase.from('meetings').select('id, title, date, time, venue').eq('status', 'upcoming').maybeSingle(),
  supabase.from('meetings').select('id, title').eq('status', 'active').maybeSingle(),
  supabase.from('meetings').select('id, title, date, venue').eq('status', 'completed').order('date', { ascending: false }),
])
```

### Meeting-scoped group membership (CRITICAL FIX)
The current dashboard queries `group_members` without meeting scope. When active meeting exists, must scope to that meeting:
```typescript
if (activeMeeting) {
  const { data: membership } = await supabase
    .from('group_members')
    .select('group:groups!inner(id, name, locked, meeting_id)')
    .eq('user_id', user.id)
    .eq('groups.meeting_id', activeMeeting.id)
    .maybeSingle()
}
```

### Meeting-scoped stations fetch
Similarly, stations must be fetched for the active meeting only:
```typescript
if (activeMeeting) {
  const { data: stations } = await supabase
    .from('stations')
    .select('id, number, title, description')
    .eq('meeting_id', activeMeeting.id)
    .order('number')
}
```

### Per-meeting attendance data
For the upcoming meeting card, fetch attendance counts:
```typescript
if (upcomingMeeting) {
  const { data: attendanceRows } = await adminClient
    .from('meeting_attendance')
    .select('user_id, attending')
    .eq('meeting_id', upcomingMeeting.id)

  // User's own attendance
  const myAttendance = attendanceRows?.find(a => a.user_id === user.id)
  const attendingCount = attendanceRows?.filter(a => a.attending === true).length ?? 0
  const notAttendingCount = attendanceRows?.filter(a => a.attending === false).length ?? 0
}
```

### Contact directory data (replacing RegisteredUsersOverview data)
The existing dashboard already fetches youth + parents via admin client. Extend this to include `phone` and `email`:
```typescript
const { data: allYouth } = await adminClient
  .from('profiles')
  .select('id, full_name, phone, email')
  .eq('role', 'youth')
  .order('full_name')

const { data: allLinks } = await adminClient
  .from('parent_youth_links')
  .select('youth_id, parent:profiles!parent_youth_links_parent_id_fkey(id, full_name, phone, email)')

// For "everyone" view: all non-admin profiles
const { data: allMembers } = await adminClient
  .from('profiles')
  .select('id, full_name, role, phone, email')
  .in('role', ['youth', 'parent'])
  .order('full_name')
```

### Components from previous plans
- `ContactDirectory` from 08-02: `src/components/dashboard/ContactDirectory.tsx`
- `AttendingToggle` from 08-01: updated `src/components/dashboard/AttendingToggle.tsx` with meetingId prop

### Patterns
- `Promise.all()` for parallel independent fetches (vercel-react-best-practices: `async-parallel`)
- Server component data fetching passed to client components as props
- Existing `revalidatePath('/dashboard')` in meeting lifecycle actions ensures dashboard refreshes on state changes
- Norwegian text: all UI labels in Norwegian bokmal

<tasks>
<task id="08-03-01" title="Build UpcomingMeetingCard and PreviousMeetingsList components">
**Files to create:**
- `src/components/dashboard/UpcomingMeetingCard.tsx`
- `src/components/dashboard/PreviousMeetingsList.tsx`

**UpcomingMeetingCard.tsx:**
1. Server component (no client state needed -- AttendingToggle is the client part)
2. Props:
```typescript
interface UpcomingMeetingCardProps {
  meeting: { id: string; title: string; date: string; time: string; venue: string }
  attendingCount: number
  notAttendingCount: number
  totalMembers: number
  initialAttending: boolean | null
}
```
3. Render a card (`rounded-xl border-2 border-teal-primary/30 bg-teal-primary/5 p-5`):
   - Meeting title as h3 (`text-base font-semibold text-text-primary`)
   - Date formatted in Norwegian: `new Date(meeting.date + 'T00:00:00').toLocaleDateString('nb-NO', { weekday: 'long', day: 'numeric', month: 'long' })`, capitalize first letter. Then ` kl. {meeting.time}`
   - Venue below date (`text-sm text-text-muted`)
   - Attendance summary: three compact pills showing `{attendingCount} kommer`, `{notAttendingCount} kan ikke`, `{totalMembers - attendingCount - notAttendingCount} ikke svart` -- use the dot indicator pattern from RegisteredUsersOverview (green/red/gray dots)
   - `AttendingToggle` embedded at the bottom with all meeting props passed through
4. BUT WAIT -- AttendingToggle is already a self-contained card with its own border/bg. To avoid double-nesting, restructure: the UpcomingMeetingCard shows the meeting info and attendance stats, and separately render `AttendingToggle` below it (not nested inside). The two components are siblings in the dashboard layout, not parent-child.
5. REVISED: `UpcomingMeetingCard` shows meeting info + attendance stats. `AttendingToggle` is rendered separately below it in the dashboard.

**PreviousMeetingsList.tsx:**
1. Server component
2. Props:
```typescript
interface PreviousMeetingsListProps {
  meetings: Array<{ id: string; title: string; date: string; venue: string | null }>
}
```
3. If `meetings.length === 0`: return null (don't show section at all)
4. Render:
   - Section heading: "Tidligere møter" (`text-lg font-semibold text-text-primary mb-3`)
   - List of compact cards (`space-y-2`)
   - Each card: `p-3 rounded-lg border border-gray-200 bg-white`
     - Meeting title (font-medium text-text-primary text-sm)
     - Date formatted in Norwegian + venue on same line (`text-xs text-text-muted`)
5. For now, these are display-only (Phase 9 will add tap-to-view-details). No links needed yet. But add a `<Link href={'/dashboard/meeting/${meeting.id}'}` wrapper so the cards are tappable (the route doesn't exist yet -- it will be created in Phase 9, but having the link ready makes the transition seamless). Actually, to avoid 404s, do NOT link yet. Just render as static cards. Add a subtle "Kommer i neste oppdatering" or nothing -- keep them as plain informational cards.

**Verification:**
- UpcomingMeetingCard displays meeting info and attendance stats correctly
- PreviousMeetingsList renders completed meetings with Norwegian dates
- Both components handle edge cases (null venue, zero attendance)
</task>

<task id="08-03-02" title="Restructure dashboard page.tsx with meeting-state-aware layout">
**File to modify:**
- `src/app/dashboard/page.tsx`

**This is the critical integration task. The entire dashboard page must be rewritten to:**

1. **Imports**: Add imports for:
   - `ContactDirectory` from `@/components/dashboard/ContactDirectory`
   - `UpcomingMeetingCard` from `@/components/dashboard/UpcomingMeetingCard`
   - `PreviousMeetingsList` from `@/components/dashboard/PreviousMeetingsList`
   - Remove import of `RegisteredUsersOverview` (replaced by ContactDirectory)
   - Keep all existing imports (StationSelector, ParentInviteBanner, AttendingToggle, Badge, Button, Link, logout, createClient, createAdminClient, redirect)

2. **Data fetching restructure** (inside the async server component):
   a. Auth check (existing -- keep as-is)
   b. Use `Promise.all()` to parallelize independent fetches:
   ```typescript
   const adminClient = createAdminClient()

   const [
     profileResult,
     upcomingResult,
     activeResult,
     previousResult,
     allYouthResult,
     allLinksResult,
     allMembersResult,
   ] = await Promise.all([
     supabase.from('profiles').select('full_name, role, parent_invite_code').eq('id', user.id).single(),
     supabase.from('meetings').select('id, title, date, time, venue').eq('status', 'upcoming').maybeSingle(),
     supabase.from('meetings').select('id, title').eq('status', 'active').maybeSingle(),
     supabase.from('meetings').select('id, title, date, venue').eq('status', 'completed').order('date', { ascending: false }),
     adminClient.from('profiles').select('id, full_name, phone, email').eq('role', 'youth').order('full_name'),
     adminClient.from('parent_youth_links').select('youth_id, parent:profiles!parent_youth_links_parent_id_fkey(id, full_name, phone, email)'),
     adminClient.from('profiles').select('id, full_name, role, phone, email').in('role', ['youth', 'parent']).order('full_name'),
   ])

   const profile = profileResult.data
   const upcomingMeeting = upcomingResult.data
   const activeMeeting = activeResult.data
   const previousMeetings = previousResult.data ?? []
   ```

   c. **Meeting-scoped group + stations** (conditional, depends on activeMeeting):
   ```typescript
   let group: { id: string; name: string; locked: boolean } | null = null
   let stations: Array<...> = []
   let sessions: Array<...> = []
   let groupMembers: Array<...> = []

   if (activeMeeting) {
     const { data: membership } = await supabase
       .from('group_members')
       .select('group:groups!inner(id, name, locked, meeting_id)')
       .eq('user_id', user.id)
       .eq('groups.meeting_id', activeMeeting.id)
       .maybeSingle()

     group = membership?.group as unknown as { id: string; name: string; locked: boolean } | null

     if (group?.id) {
       const [stationsResult, sessionsResult, membersResult] = await Promise.all([
         supabase.from('stations').select('id, number, title, description').eq('meeting_id', activeMeeting.id).order('number'),
         supabase.from('station_sessions').select('station_id, id, status, end_timestamp').eq('group_id', group.id),
         supabase.from('group_members').select('profile:profiles!inner(full_name, role)').eq('group_id', group.id),
       ])
       stations = stationsResult.data ?? []
       sessions = sessionsResult.data ?? []
       groupMembers = (membersResult.data ?? []).map(m => m.profile as unknown as { full_name: string; role: string })
     }
   }
   ```

   d. **Per-meeting attendance** (conditional, depends on upcomingMeeting):
   ```typescript
   let myAttendance: boolean | null = null
   let attendingCount = 0
   let notAttendingCount = 0
   let totalMembers = 0

   if (upcomingMeeting) {
     const { data: attendanceRows } = await adminClient
       .from('meeting_attendance')
       .select('user_id, attending')
       .eq('meeting_id', upcomingMeeting.id)

     myAttendance = attendanceRows?.find(a => a.user_id === user!.id)?.attending ?? null
     attendingCount = attendanceRows?.filter(a => a.attending === true).length ?? 0
     notAttendingCount = attendanceRows?.filter(a => a.attending === false).length ?? 0

     const { count } = await adminClient
       .from('profiles')
       .select('*', { count: 'exact', head: true })
       .in('role', ['youth', 'parent'])
     totalMembers = count ?? 0
   }
   ```

   e. **Contact directory data** (shape the data for ContactDirectory props):
   ```typescript
   const youthWithParents = (allYouthResult.data ?? []).map(y => ({
     id: y.id,
     full_name: y.full_name,
     phone: y.phone as string | null,
     email: y.email as string,
     parents: (allLinksResult.data ?? [])
       .filter(l => l.youth_id === y.id)
       .map(l => l.parent as unknown as { id: string; full_name: string; phone: string | null; email: string })
       .filter(Boolean),
   }))

   const everyone = (allMembersResult.data ?? []).map(m => ({
     id: m.id,
     full_name: m.full_name,
     role: m.role as 'youth' | 'parent' | 'admin',
     phone: m.phone as string | null,
     email: m.email as string,
   }))
   ```

3. **JSX restructure**:
   - Keep: welcome header, admin link, logout button
   - Replace the entire conditional render block with the new meeting-state-aware layout:

   ```tsx
   {/* Active meeting with locked group: show stations */}
   {activeMeeting && group?.locked && stations.length > 0 && (
     <>
       <GroupAssignmentCard group={group} groupMembers={groupMembers} />
       <StationSelector stations={stations} sessions={sessions} groupId={group.id} />
     </>
   )}

   {/* Upcoming meeting: show meeting card + attendance toggle */}
   {upcomingMeeting && !activeMeeting && (
     <>
       <UpcomingMeetingCard
         meeting={upcomingMeeting}
         attendingCount={attendingCount}
         notAttendingCount={notAttendingCount}
         totalMembers={totalMembers}
       />
       <AttendingToggle
         meetingId={upcomingMeeting.id}
         meetingTitle={upcomingMeeting.title}
         meetingDate={upcomingMeeting.date}
         meetingTime={upcomingMeeting.time}
         meetingVenue={upcomingMeeting.venue}
         initialAttending={myAttendance}
       />
     </>
   )}

   {/* Upcoming meeting during active: also show attendance (smaller) */}
   {upcomingMeeting && activeMeeting && (
     <AttendingToggle
       meetingId={upcomingMeeting.id}
       meetingTitle={upcomingMeeting.title}
       meetingDate={upcomingMeeting.date}
       meetingTime={upcomingMeeting.time}
       meetingVenue={upcomingMeeting.venue}
       initialAttending={myAttendance}
     />
   )}

   {/* Parent invite banner (existing) */}
   {showParentInvite && <ParentInviteBanner inviteCode={profile!.parent_invite_code!} />}

   {/* Group preview when assigned but not locked (active meeting) */}
   {activeMeeting && group && !group.locked && (
     <GroupPreview group={group} groupMembers={groupMembers} />
   )}

   {/* Not assigned to group message (active meeting) */}
   {activeMeeting && !group && (
     <p className="text-text-muted mb-4">
       Du er ikke tildelt gruppe ennå. Tildelingen skjer før møtet.
     </p>
   )}

   {/* Contact Directory -- ALWAYS shown */}
   <ContactDirectory youth={youthWithParents} everyone={everyone} />

   {/* Previous meetings */}
   <PreviousMeetingsList meetings={previousMeetings} />
   ```

4. **Remove**: the `RegisteredUsersOverview` usage and the old attendance-related data fetching (`profiles.attending` queries, `attendingCount`/`notRespondedCount` computation). The `attending` field is no longer read from profiles for dashboard display.

5. **Inline helper components**: The group assignment card and group preview can remain as inline JSX (as they currently are) -- no need to extract them into separate components since they're small and only used here.

**Verification:**
- Dashboard renders correctly in all three states: active meeting, upcoming meeting, no meeting
- Contact directory appears in all states
- Group membership is correctly scoped to the active meeting
- Stations are fetched for the active meeting only
- Attendance is fetched from `meeting_attendance` table for the upcoming meeting
- Previous meetings list shows completed meetings
- No waterfall in data fetching (independent queries use Promise.all)
- TypeScript compiles without errors
- Mobile layout works on 375px width
</task>
</tasks>

## Verification Criteria

1. **DASH-01**: Dashboard shows different content based on meeting state (upcoming card, active stations, or directory-only)
2. **DASH-02**: Previous meetings are listed with date and venue
3. **DIR-01 through DIR-04**: Contact directory is always visible with search, two views, and tappable contact links
4. **SCOPE-02**: Attendance is read from `meeting_attendance` table (per-meeting, not global)
5. **Meeting scoping**: Group membership and station queries are scoped to the active meeting ID
6. **Performance**: Independent data fetches use `Promise.all()` to eliminate waterfalls
7. **No regressions**: Admin link, logout, parent invite banner all still work
